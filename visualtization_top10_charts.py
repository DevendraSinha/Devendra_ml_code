# -*- coding: utf-8 -*-
"""VISUALTIZATION-TOP10-CHARTS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1X71wxTf2jbQuB2hIvtOJCkq2JynjGE_z

### **1. BAR CHART**

## Column Bar chart.It is used to compare data between of subgroup within a group


*   In the below example we have a group called A.Under this group there are 2 subgroups.We are comparing the values of these subgroups.
"""

import matplotlib.pyplot as plt
import numpy as np

# Sample data
categories = ['A', 'B', 'C']
values1 = [10, 15, 12]
values2 = [8, 18, 10]

# Set the width of the bars
barWidth = 0.3

# Set the positions of the bars on the x-axis
r1 = np.arange(len(values1))
r2 = [x + barWidth for x in r1]

# Create the bar plot
plt.bar(r1, values1, width=barWidth, label='Group 1')
plt.bar(r2, values2, width=barWidth, label='Group 2')

# Add labels, title, and legend
plt.xlabel('Categories')
plt.ylabel('Values')
plt.title('Grouped Bar Chart')
plt.xticks([r + barWidth/2 for r in range(len(values1))], categories)
plt.legend()

# Display the plot
plt.show()

"""## Stacked bar charts “stack” sub-group bars on top of each other, making it simple to see the contribution of each sub-group to a total value."""

import matplotlib.pyplot as plt
import numpy as np

# Sample data
categories = ['A', 'B', 'C']
values1 = [10, 15, 12]
values2 = [8, 18, 10]

# Set the positions of the bars on the x-axis
r = np.arange(len(categories))

# Create the stacked bar plot
plt.bar(r, values1, label='Group 1')
plt.bar(r, values2, bottom=values1, label='Group 2') # Stack 'Group 2' on top of 'Group 1'


# Add labels, title, and legend
plt.xlabel('Categories')
plt.ylabel('Values')
plt.title('Stacked Bar Chart')
plt.xticks(r, categories)
plt.legend()

# Display the plot
plt.show()

"""## **2. Line Chart**

Below example compares multi device usgae with time
"""

import matplotlib.pyplot as plt

# Sample data (replace with your actual data)
time = [1, 2, 3, 4, 5, 6]  # Time points or dates
device_a = [10, 15, 12, 18, 20, 22]  # Usage of product A by device A
device_b = [5, 8, 10, 12, 15, 18]  # Usage of product A by device B
device_c = [2, 4, 6, 8, 10, 11] # Usage of product A by device C

# Create the line plot
plt.plot(time, device_a, label='Device A')
plt.plot(time, device_b, label='Device B')
plt.plot(time, device_c, label='Device C')


# Add labels, title, and legend
plt.xlabel('Time')
plt.ylabel('Product Usage')
plt.title('Track Product Usage by Device with Time')
plt.legend()

# Display the plot
plt.show()

"""## **3.Funnel chart**

Funnel charts illustrate the progressive reduction of data as it passes through multiple phases. Essentially, these data analytics charts lay out a process that begins at 100% and follows a smaller percentage after each stage so you can visualize, for example, how many leads progressed through a sales process
"""

import matplotlib.pyplot as plt

def plot_funnel_chart(stages, values):
    """
    Plots a funnel chart.

    Args:
        stages: A list of strings representing the stages in the funnel.
        values: A list of numbers representing the values for each stage.
    """

    # Calculate the width of each section based on its value
    total_value = sum(values)
    widths = [value / total_value for value in values]

    # Set the positions of the bars on the y-axis
    y_pos = range(len(stages))

    # Create the funnel plot
    plt.barh(y_pos, widths, align='center', height=0.8)  # Use horizontal bar chart

    # Add labels, title, and formatting
    plt.yticks(y_pos, stages)
    plt.xlabel("Percentage")  # Set x-axis label
    plt.title("Funnel Chart")  # Set title

    # Annotate each bar with its value
    for i, v in enumerate(values):
        plt.text(widths[i], i, f'{v}', color='black', va='center')  # Add labels inside bars

    # Display the chart
    plt.show()


# Example Usage:
stages = ['Awareness', 'Consideration', 'Decision', 'Action']
values = [1000, 500, 250, 100]

plot_funnel_chart(stages, values)

"""## **4.HeatMap**

Heatmaps are especially helpful for tracking navigational data within an app or website, allowing us to:

> Display data density to identify concentrations or patterns within a specific
  data set.
> Analyze user engagement on a website or application.
> Optimize your website or app to incentivize specific user behavior.

One way to leverage heatmaps is to analyze your website visitor’s activity. This way, you can see which buttons are most clicked and optimize your landing pages to drive more conversions.
"""

import matplotlib.pyplot as plt
import numpy as np

# Sample website visitor activity data (replace with your actual data)
# Rows represent pages, columns represent time intervals (e.g., hours)
activity_data = np.random.randint(0, 100, size=(5, 10))  # Example data

# Create the heatmap
plt.imshow(activity_data, cmap='hot', interpolation='nearest')  # Use 'hot' colormap

# Customize the plot (add labels, title, colorbar, etc.)
plt.colorbar()  # Add colorbar
plt.title('Website Visitor Activity Heatmap')
plt.xlabel('Time Interval')
plt.ylabel('Page')

# Add page labels
page_labels = ['Home', 'Products', 'About', 'Contact', 'Blog']  # Replace with your page names
plt.yticks(np.arange(len(page_labels)), page_labels)


# Add time interval labels (if needed)
time_labels = np.arange(10)
plt.xticks(np.arange(len(time_labels)), time_labels)
# Display the plot
plt.show()

"""# **5.Bubble chart**

A bubble chart is a graph that uses bubbles to display three dimensions of data. It's a variation of a scatter plot, where the data points are replaced by bubbles.
How it works
Each bubble represents a data point
The horizontal and vertical position of the bubble shows the values of two of the data dimensions
The size of the bubble shows the value of the third data dimension
"""

import matplotlib.pyplot as plt

def plot_bubble_chart(x_values, y_values, bubble_sizes, x_label, y_label, title):
    """
    Plots a bubble chart.

    Args:
        x_values: A list of x-axis values.
        y_values: A list of y-axis values.
        bubble_sizes: A list of bubble sizes corresponding to the data points.
        x_label: Label for the x-axis.
        y_label: Label for the y-axis.
        title: Title of the chart.
    """
    plt.figure(figsize=(10, 6))  # Adjust figure size as needed
    plt.scatter(x_values, y_values, s=bubble_sizes, alpha=0.7)

    plt.xlabel(x_label)
    plt.ylabel(y_label)
    plt.title(title)
    plt.grid(True)
    plt.show()


# Example usage (replace with your actual commerce data):
# Assuming you have data in these lists:
#   x_values:  e.g., Revenue, Sales Quantity, etc
#   y_values:  e.g., Profit Margin, Customer Acquisition Cost, etc.
#   bubble_sizes:  e.g., Number of Orders, Customer Lifetime Value, etc.
x_values = [10, 15, 20, 25, 30]
y_values = [5, 10, 12, 18, 22]
bubble_sizes = [100, 200, 300, 400, 500] #Example sizes - scale as needed for your data

plot_bubble_chart(x_values, y_values, bubble_sizes, "Revenue", "Profit Margin", "Commerce Data Analysis")

"""## **6 Dot data analytics charts**

Dot chart types


1. **Basic Dot Charts**: They’re useful to present grouped or clustered data points, where each dot represents an individual data point. It can provide a simple, clean visualization of sample data without any adjustment.

2.  **Cleveland Dot Charts**: It emphasizes the relative position of data points along a common horizontal (or vertical) line, making it easier to compare different data points and observe trends within your dataset. It’s very similar to a bar chart but uses dots instead.

3. **Quantile Dot Charts (Wilkinson chart)**: This chart uses dots to display density. It can effectively illustrate the variation or distribution across different categories, magnitudes, or periods—making it useful for large data sets
"""

import plotly.graph_objects as go
import pandas as pd
import numpy as np

# Sample data (replace with your actual data)
np.random.seed(42)  # for reproducibility
categories = ['A', 'B', 'C', 'D']
data = {
    'Category': np.random.choice(categories, size=100),
    'Value': np.random.normal(loc=10, scale=3, size=100)
}
df = pd.DataFrame(data)

# Create the Quantile Dot Chart (Wilkinson Chart)
fig = go.Figure()

for category in categories:
    category_data = df[df['Category'] == category]['Value']
    fig.add_trace(go.Scatter(
        x=category_data,
        y=[category] * len(category_data),
        mode='markers',
        marker=dict(size=8),
        name=category
    ))

fig.update_layout(
    title='Quantile Dot Chart (Wilkinson Chart)',
    xaxis_title='Value',
    yaxis_title='Category',
    yaxis={'categoryorder': 'total ascending'}  # Order categories by total dot count
)
fig.show()

import plotly.graph_objects as go
import numpy as np
import pandas as pd

def plot_quantile_dot_chart_plotly(data, categories, title="Quantile Dot Chart"):
    """
    Plots a quantile dot chart using Plotly.

    Args:
        data: A list of lists, where each inner list represents data for a category.
        categories: A list of category labels.
        title: The title of the chart.
    """

    fig = go.Figure()

    for i, category_data in enumerate(data):
        quantiles = np.quantile(category_data, [0.25, 0.5, 0.75])
        fig.add_trace(go.Scatter(
            x=[i] * len(quantiles),
            y=quantiles,
            mode='markers',
            marker=dict(size=8, color='skyblue'),
            name=categories[i]
        ))
        fig.add_trace(go.Scatter(
            x=[i,i],
            y=[quantiles[0],quantiles[2]],
            mode='lines',
            line=dict(color='skyblue'),
            showlegend=False
        ))


    fig.update_layout(
        title=title,
        xaxis_title="Categories",
        yaxis_title="Values",
        xaxis={'tickvals':list(range(len(categories))),
               'ticktext':categories},
        yaxis=dict(showgrid=True, gridwidth=1, gridcolor='LightGrey'),
        plot_bgcolor='white'
    )
    fig.show()

# Sample data
data = [
    np.random.normal(loc=10, scale=2, size=50),
    np.random.normal(loc=15, scale=3, size=50),
    np.random.normal(loc=12, scale=2.5, size=50)
]
categories = ['Category A', 'Category B', 'Category C']
plot_quantile_dot_chart_plotly(data, categories)

import matplotlib.pyplot as plt
import numpy as np

def plot_cleveland_dot_chart(data, categories, title="Cleveland Dot Chart"):
    """
    Plots a Cleveland dot chart.

    Args:
        data: A list of lists, where each inner list represents data for a category.
        categories: A list of category labels.
        title: The title of the chart.
    """

    plt.figure(figsize=(10, 6))  # Adjust figure size as needed

    num_categories = len(categories)
    for i, category_data in enumerate(data):
        y_coords = [i] * len(category_data)  # y-coordinate for all data points in the category
        plt.plot(category_data, y_coords, 'o', markersize=8, color='skyblue')


    # Customize the plot
    plt.yticks(range(num_categories), categories)
    plt.xlabel("Values")
    plt.ylabel("Categories")
    plt.title(title)
    plt.grid(axis='x', linestyle='--', alpha=0.7)
    plt.tight_layout()
    plt.show()


# Example Usage:
data = [
    [12, 15, 18, 20, 14],  # Data for Category A
    [10, 8, 11, 9, 12],    # Data for Category B
    [16, 19, 17, 22, 21]   # Data for Category C
]
categories = ['Category A', 'Category B', 'Category C']
plot_cleveland_dot_chart(data, categories)

"""## **7.Stacked area chart**

A stacked area chart is a multilayered graphic that accumulates data points from multiple categories to create a cumulative effect, with each layer representing a different category.

It uses the “area” beneath the lines to represent volume, making it useful when you need to display how individual categories contribute to the whole over time while maintaining the total and proportions of each category intact.
"""

import plotly.graph_objects as go

# Sample data (replace with your actual data)
categories = ['A', 'B', 'C']
x_values = ['Jan', 'Feb', 'Mar', 'Apr', 'May']
values1 = [10, 15, 12, 18, 20]
values2 = [8, 18, 10, 15, 12]
values3 = [5, 10, 8, 12, 15]

fig = go.Figure()
fig.add_trace(go.Scatter(
    x=x_values,
    y=values1,
    fill='tozeroy',  # Fill area to the y=0 line
    mode='lines',
    name='Category A',
    line=dict(width=0.5, color='blue'),
    stackgroup='one' # Stack this trace with others of the same group
))

fig.add_trace(go.Scatter(
    x=x_values,
    y=values2,
    fill='tonexty',  # Fill area to the previous trace's y-value
    mode='lines',
    name='Category B',
    line=dict(width=0.5, color='red'),
    stackgroup='one'
))

fig.add_trace(go.Scatter(
    x=x_values,
    y=values3,
    fill='tonexty',  # Fill area to the previous trace's y-value
    mode='lines',
    name='Category C',
    line=dict(width=0.5, color='green'),
    stackgroup='one'
))

# Customize the layout
fig.update_layout(
    title="Stacked Area Chart",
    xaxis_title="Time Period",
    yaxis_title="Values",
)

fig.show()

"""### **8. TreeMap**

A treemap chart provides a hierarchical view of your data and makes it easy to spot patterns, such as which items are a store's best sellers. The tree branches are represented by rectangles and each sub-branch is shown as a smaller rectangle
"""

import plotly.express as px

# Sample customer data (replace with your actual data)
data = {
    'Customer ID': [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
    'Region': ['East', 'West', 'East', 'South', 'West', 'East', 'North', 'South', 'North', 'West'],
    'Category': ['A', 'B', 'A', 'C', 'B', 'A', 'C', 'B', 'A', 'C'],
    'Subcategory': ['A1', 'B1', 'A2', 'C1', 'B2', 'A3', 'C2', 'B1', 'A1', 'C3'],
    'Sales': [100, 150, 120, 80, 180, 110, 90, 160, 130, 100]
}
df = px.data.tips() # example dataframe, replace with yours

fig = px.treemap(df, path=['day', 'time', 'sex'], values='total_bill')
fig.show()

"""## **9.SunBurst Chart**

The sunburst chart is ideal for displaying hierarchical data. Each level of the hierarchy is represented by one ring or circle with the innermost circle as the top of the hierarchy. A sunburst chart without any hierarchical data (one level of categories), looks similar to a doughnut chart. However, a sunburst chart with multiple levels of categories shows how the outer rings relate to the inner rings. The sunburst chart is most effective at showing how one ring is broken into its contributing pieces
"""

import plotly.express as px

# Sample data (replace with your actual data)
data = dict(
    character=["Eve", "Cain", "Seth", "Enos", "Noam", "Abel", "Awan", "Enoch", "Azura"],
    parent=["", "Eve", "Eve", "Seth", "Seth", "Eve", "Eve", "Awan", "Eve"],
    value=[10, 14, 12, 10, 2, 6, 6, 4, 4])

fig = px.sunburst(
    data,
    names='character',
    parents='parent',
    values='value',
)
fig.show()

"""### **10.Whisker Chart**

A box and whisker chart shows distribution of data into quartiles, highlighting the mean and outliers. The boxes may have lines extending vertically called “whiskers”. These lines indicate variability outside the upper and lower quartiles, and any point outside those lines or whiskers is considered an outlier.
"""

import plotly.graph_objects as go

# Sample data (replace with your actual data)
data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,30]

fig = go.Figure(data=[go.Box(y=data)])
fig.show()

"""### **11.Distribution Plot**"""

import plotly.figure_factory as ff

# Sample skewed data (replace with your actual data)
data = [1, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 50]  # Example skewed data

# Create the distplot with kde
fig = ff.create_distplot([data], ['Skewed Data'], show_hist=True, show_rug=False) #show_rug=False to remove the rug plot

# Customize the plot (optional)
fig.update_layout(
    title="Distribution Plot of Skewed Data",
    xaxis_title="Value",
    yaxis_title="Density"
)

fig.show()